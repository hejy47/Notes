# 科研笔记

## 2021/9/19

### 论文写作技巧

#### 写作重点

1. Abstract
2. Introduction
3. Research Questions

#### 研究问题

1. 贴合实际：所提出的研究问题需要落地，不能空中楼阁
2. 符合需求：提出的问题确实是研究者们所需要知道的，想要解决的。

#### 实验方法

先确定实验方法（通过research proposal以及论文大纲），在按照实验方法进行实验，避免实验与所确定的方法不符合。

#### 结果分析

任何一个观点都要有理有据，不能想当然。

## 2021/12/10

### 论文汇报（CirFix : Automatically Repairing Defects in Hardware Design Code）

1. 基于数据流的故障定位方法（程序切片技术）
2. 基于搜索的修复方法（遗传算法，GenProg）
3. 数据集构建

### 问题与想法

1. 程序切片技术是无序的，在大型项目中不可用
2. 修复模式的扩充与改进
3. 搜索算法的改进（遗传算法可能导致局部最优）
4. 评估函数的改进
5. 针对于HDL的缺陷（时序上的缺陷，并发程序上的缺陷）

### 下一步工作

1. 根据educoder构造数据集（1-2周）
2. 改进故障定位方法：直接使用SFL（<1周）
3. 改进修复方法（>2周)
   1. 改进修复模式
   2. 使用代码复用策略
   3. 使用约束求解方法？

## 2021/12/11

### Verilog数据集构建准则

1. 使用educoder中的学生作业项目进行构建：
   1. 考虑无测试代码更改的failing-passing的构建
2. 缺陷引入准则
   1. 缺陷一定可复现
   2. 缺陷已经被学生修复
3. Testbench构建准则
   1. 在已有的testbench上记录更小密度的时间戳值
   2. 使用fuzzing进行测试用例的扩充（如果需要，避免偏差）

#### 一些想法

1. 故障版本和修复版本不一定时连续的前后提交。一般而言，学生的最后一次提交是正确版本，之前的版本都是故障版本，可以构建多个<故障，修复>对。
   1. 问题：更早的故障版本可能错误不止一处。
2. 提取学生的修复动作，将其反转复现其学生的故障版本。
   1. 每次的故障版本包括一个缺陷；
   2. 不通过checkout进行构建，是否违背了真实性？

## 2021/12/17

### 数据集构建

1. 通过打补丁的方式隔离缺陷
   1. 潜在的问题：引入了未来的代码，而这部分代码可能被修复工具所使用；
   2. 只考虑<vi, vn>的情况，其中i ∈ [1, n-1]，commit总共有n个；
2. 测试用例增强
   1. 现象：老师构建的测试用例不够完善，导致学生的提交可能仅通过测试用例？（需要核实）
   2. 通过Fuzzing自动化地构造测试用例；
3. Educoder项目地址
   1. 课程：[计算机组成与设计实训-用Verilog HDL玩转计算机硬件系统设计](https://www.educoder.net/paths/431)
   2. 课程：[数字逻辑与数字电路实训-用Verilog HDL玩转数字系统设计](https://www.educoder.net/paths/1027)
   3. https://www.educoder.net/shixuns/x4qhb5k7/challenges
   4. https://www.educoder.net/shixuns/wgfyrzhe/challenges
   5. https://www.educoder.net/shixuns/ay2g439n/challenges
   6. https://www.educoder.net/shixuns/ofqxthrf/challenges
   7. https://www.educoder.net/shixuns/58cg39ol/challenges
   8. https://www.educoder.net/shixuns/nfpla5jg/challenges
   9. https://www.educoder.net/shixuns/ohkunqe2/challenges
   10. https://www.educoder.net/shixuns/u3j28qe6/challenges
   11. https://www.educoder.net/shixuns/egxr5sit/challenges

### 修复算法改进

1. 强化学习
   1. 是否需要大量的数据进行学习？搜索空间是不是很大？（复现RLAssist）
   2. 使用Error message改进Reward；
2. 约束求解
   1. 通过出错语句前后的变量/信号值得到约束；
   2. 将约束送入到求解器进行求解；

## 2021/12/23

### RLAssist复现的一些问题

1. 数据集构建
   1. 训练集，验证集和测试集是已经选好了的；
   2. 训练集和验证集都是存在变异程序的；
   3. K折交叉验证：使用5折交叉验证；
2. 模型
   1. Error message只考虑了出错的个数，没考虑具体信息；

### Educoder数据集构建相关问题

1. 故障-修复对只考虑<vi, vn>的情况，其中i ∈ [1, n-1]，commit总共有n个；
   1. 两个版本之间可能会引入多个缺陷；
   2. 存不存在学生提交通过后再提交的可能；
2. 人工筛选
   1. 不满足要求的缺陷；
   2. 重复的缺陷；
   3. 学生代码重构（需要把重构的代码删除）；

## 2022/1/7

### CirFix调试

参考CirFix使用的定位和修复方法都和GenProg一致，在这里对CirFix进行调试，以便后续的改进。

1. 基于程序切片的方法在CirFix中发挥的作用不大。CirFix在其数据集上表现优秀有部分原因是小规模程序的搜索空间很小。
2. 遗传算法在CirFix的补丁搜索指导上没有发挥作用。将随机搜索算法替换成遗传算法，CirFix也能修复缺陷并且修复时间普遍更短。

通过调试，发现CirFix存在着和GenProg同样的问题。因此，改进算法可以从两方面入手：改进定位方法（在小程序上做修复改进定位方法意义不带）；改进遗传算法（初步想到的是用强化学习，但是感觉强化学习也不能指导补丁搜索，而且学习需要大量的数据）。

### 和师兄交流的一些想法的记录

1. 目前修复有三大方向（基于搜索、基于模板、基于代码复用），并且感觉后续的研究方向是：
   1. 基于深度搜索，指导补丁的搜索。
   2. 深度模板合成，使用神经网络进行深度模板的自动提取。
   3. 方法级别的代码复用。目前的使用的代码复用都是基于语句级别，后续可以考虑基于方法级别，但是感觉粒度太大了不利于代码搜索；使用控制流图进行相似代码匹配，找到语义上相似的代码。
2. 在CirFix的改进上，可以从修复算子入手，从搜索空间（时间开修）和修复效果上做权衡。
3. 基于控制流图的相似代码匹配，使用参考程序（老师程序）对学生程序进行修复。
4. 通过代码复用（代码克隆），进行代码修复的移植（补丁移植），来达到其他位置的代码修复的提醒。

## 2022/1/13

### FPGA讨论

1. 传统的SFL用不了，用了新的定位技术（事实上就是程序切片技术）。
2. 找到突破点：
   1. 找到硬件描述语言的特性，做出定位方法和修复方法的突破。
   2. 在FPGA中，每一功能点对应一个组件，多点缺陷可能对应着多个组件。
   3. 在RTL级别上进行修复。

### 多点修复

#### 代码克隆检测工具调研结果

| 工具 | 核心思想 | 检测语言 | 开源地址 | 发布会议 | 最高检测类型 |
|------|------|----|----|----|----|
| CCAligner | 利用滑动窗口和非精确匹配算法来计算相似性 | C, Java | https://github.com/PCWcn/CCAligner | ICSE'18 | 3 |
| SourcererCC | 优化的反向索引结构和过滤的启发式算法实现大规模克隆检测 | Java, C, C# | https://github.com/Mondego/SourcererCC | ICSE'16 | 3 |
| CCFinder | -- | -- | -- | -- | 2 |
| Clonecognition | 基于机器学习的代码克隆检测 | Java | https://github.com/pseudoPixels/cloneCognition | ESEC/FSE'19 | 4 |
| JCCD | 解析成token/AST，分而治之进行比较 | Java | http://jccd.sourceforge.net/ | ASE'10 | 3 |
| Deckard | 利用解析器来生成解析树，用向量来获得树的结构信息，使用LSH进行聚类 | C, Java | https://github.com/skyhover/Deckard | ICSE'07 | 3 |
| LICCA | 使用基于树的中间表示和LCS进行克隆检测 | Java | https://github.com/tvislavski/licca | SANER'16 | 3 |
| ASTNN | 将AST分解，并编码成向量，使用双向GRU生成向量表示 | C, Java | http://github.com/zhangj111/astnn | ICSE'19 | 4 |
| CCGraph | 基于图核的近似图匹配算法计算相似性 | Java, C | 不开源 | ASE'20 | 4 |
| DeepSim | 将代码片段的控制流和数据流编码到语言矩阵中，设计DNN来度量代码功能相似性 | Java | https://github.com/parasol-aser/deepsim | ESEC/FSE'18 | 4 |
| Mecc | 通过语义静态分析技术收集抽象内存状态，并通过比较内存状态判断代码相似性 | Python,Java,SQL | http://ropas.snu.ac.kr.mecc | ICSE'11 | 4 |
| Oreo | 使用24中度量（包括声明变量的数量）表示一个代码片段，然后使用48维向量训练二进制分类器 | Java | 不开源 | ESEC/FSE'18 | 3 |

考虑到：1）工具需要能够检测尽可能高类型的代码克隆（至少能够检测类型3）；2）使用学习的方法的工具需要进行训练（有可能需要标数据）；3）工具发布的会议是最近的顶会并且引用量更高；4）工具已经开源。综合考虑决定使用SourcererCC，这个工具的引用量有300多，并且被多个检测工具进行比较，还是有代表性的。

#### SourcererCC使用记录（2022/1/15）

教程以及报错处理：

1. 根据代码仓库的README进行操作即可。
   1. Tokenize source code
   2. Run SourcererCC
2. 报错处理：执行controller.py报一下错误："__main__.ScriptControllerException: error during init."
   1. 原因：未安装ant，在执行runnodes.sh时，`ant ... clean cdi`无法执行成功

使用记录：

1. 使用自带的数据集，并在file级别上运行成功。
2. 使用自带的数据集，并在function级别上运行成功。

## 2022/1/24

### 师兄建议

1. 整理数据集
2. 关注时序语句不能修复的语句（case语句，时序语句）
3. 观察基于程序谱的缺陷定位

58，64能找到donor code
20，30，47，46是多点修复，找到的克隆也是被修复的
48，59，60，44，61找到的克隆对没有donor code，50找到的克隆对有部分donor code

## 2022/3/20

工作安排：

1. 查看ASPLOS历年来关于Bug的文章，捕捉Bug的趋势。
2. 重点关注并发缺陷（Concurrency Bug）。
3. 目前FPGA缺陷修复的方法：静态修复。

思路：

1. value-flow analysis
2. FSM
