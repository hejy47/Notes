# 科研笔记

## 2021/9/20

### Dissection of a Bug Dataset: Anatomy of 395 Patches from Defects4J

#### Abstract

1. 设计良好的bug数据集对于推进故障定位和程序修复的作用。（重要性）
2. 这些数据集需要被研究者深入了解。（需求）
3. 目前没有广泛的方法对其进行分析。（现状）
4. 基于此现状，作者提出的方法。（工作）
5. 实验结果的分析。（结果）
6. 实验结果的影响。（贡献）

#### Introduction

1. 公开可用的bug数据集的作用。
2. 研究者们需要数据集的详细信息
   1. 根据所考虑的技术（采样和包含标准），仅选择具有所需属性的bug
   2. 根据缺陷或补丁的某些属性，对新提出的技术的性能进行高级分析（相关性分析）
3. 作者聚焦于Defect4J数据集，做了深入的分析。
4. 作者回答了以下四个问题。
5. 这篇论文研究的意义：利用只包含添加代码的补丁的技术；特定于修复模式的修复算法。

#### Research Questions

1. What is the size distribution of Defects4J patches?
2. To what extent are Defects4J patches spread in source code?
3. What is the composition of Defects4J patches in terms of repair actions (i.e. addition, removal and modification) over code elements (e.g. conditional and method call)?
4. What repair patterns can be found in Defects4J using a manual thematic analysis?

### A Closer Look at Real-World Patches

#### Research Questions

1. Do patches impact some specific statement types?
2. Are there code elements in statements that are prone to be faulty?
3. Which expression types are most impacted by patches?
4. Which parts of buggy expressions are prone to be buggy?


## 2021/11/3

### Multi-point repair

#### Papers

- ARJA: Automated Repair of Java Programs via Multi-Objective Genetic Programming (ARJA)
- A hybrid evolutionary system for automatic software repair (ARJA-e)
- Making Better Use of Repair Templates in Automated Program Repair: A Multi-Objective Approach (ARJA-p)

#### Approaches

- Program synthesis
   - Angelix (Angelix: Scalable multiline program patch synthesis via symbolic analys is.)
- Pattern-based repair
  - HERCULES (Harnessing evolution for multi-hunk program repair.)
- Iterative repair
  - DeepFix (Deepfix: Fixing common c language errors by deep learning.)
- Search-based repair

#### Multi-objective evolutionary algorithm, MOEA

- Multi-objective optimization problem (MOP): 
$$
\begin{array}{r}
\min \mathbf{f}(\mathbf{x})=\left(f_{1}(\mathbf{x}), f_{2}(\mathbf{x}), \ldots, f_{m}(\mathbf{x})\right)^{\mathrm{T}} \\
\text { subject to } \mathbf{x} \in \Omega \subseteq \mathbb{R}^{n}
\end{array}
$$
- Pareto dominance-based MOEAs (e.g. NSGA-II, $\theta$-DEA, MOEA/D-DU)
- Multi-Objective Genetic Programming
- **Multi-Objective Different Evolution (MODE)**
  - faster convergence rate
  - efficient global search capability
- Self-organizing multi-objective evolutionary algorithm (SMEA)

## 2021/12/11

### Benchmark

#### 文章

- BEARS: An Extensible Java Bug Benchmark for Automatic Program Repair Studies
- Exploring True Test Overfitting in Dynamic Automated Program Repair using Formal Methods

#### 准则

##### Bears

1. 故障修复的两种情况
   1. 无测试代码更改的failing-passing的建立
   2. 有测试代码更改的passing-passing的建立
2. 项目引入准则
   1. 项目在GitHub上公开可用
   2. 必须使用Travis持续集成服务（CI）
   3. 必须是Maven项目
3. 缺陷引入准则
   1. 缺陷一定可复现
   2. 缺陷一定已经被人类修复

##### Java+JML、Buggy Java Programs

1. Java+JML：带有完整形式化行为规约的Java程序数据集
2. 测试套件：使用fuzzer（如Kelinci fuzzing tool）生成测试，避免偏差
3. 数据集构建：使用PITest进行故障注入

#### Verilog数据集构建准则

1. 使用educoder中的学生作业项目进行构建：
   1. 考虑无测试代码更改的failing-passing的构建
2. 缺陷引入准则
   1. 缺陷一定可复现
   2. 缺陷已经被学生修复
3. Testbench构建准则
   1. 在已有的testbench上记录更小密度的时间戳值
   2. 使用fuzzing进行测试用例的扩充（如果需要，避免偏差）

#### 一些想法

1. 故障版本和修复版本不一定时连续的前后提交。一般而言，学生的最后一次提交是正确版本，之前的版本都是故障版本，可以构建多个<故障，修复>对。
   1. 问题：更早的故障版本可能错误不止一处。
2. 提取学生的修复动作，将其反转复现其学生的故障版本。
   1. 每次的故障版本包括一个缺陷；
   2. 不通过checkout进行构建，是否违背了真实性？